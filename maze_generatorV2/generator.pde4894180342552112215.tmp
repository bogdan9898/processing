class GENERATOR {
  float x;
  float y;
  int i;
  int j;
  //boolean generating = true;
  ArrayList<PVector> path;

  GENERATOR(int i, int j) {
    this.x = g[i][j].x;
    this.y = g[i][j].y;
    this.i = i;
    this.j = j;
    path = new ArrayList<PVector>();
  }

  void move() {
    setMaze(i, j);
    //searchDrum(i, j);
    if (searchDrum(i, j)) {
      path.add(new PVector(i, j));
      int dir = floor(random(4));
      switch (dir) {
      case 0: //SUS
        if (j > 0 && g[i][j-1].isSet == false) {
          delWalls(i, j, dir);
          j -= 1;
          y = g[i][j].y;
        } else move();
        break;
      case 1: //DREAPTA
        if (i < r-1 && g[i+1][j].isSet == false) {
          delWalls(i, j, dir);
          i += 1;
          x = g[i][j].x;
        } else move();
        break;
      case 2: //JOS
        if (j < c-1 && g[i][j+1].isSet == false) {
          delWalls(i, j, dir);
          j += 1;
          y = g[i][j].y;
        } else move();
        break;
      case 3: //STANGA
        if (i > 0 && g[i-1][j].isSet == false) {
          delWalls(i, j, dir);
          i -= 1;
          x = g[i][j].x;
        } else move();
        break;
      }
    } else {
      //println("reverse");
      if (path.size() >= 1) {
        PVector aux = path.get(path.size()-1);
        i = int(aux.x);
        j = int(aux.y);
        x = g[i][j].x;
        y = g[i][j].y;
        path.remove(path.size()-1);
        //noLoop();
      }
    }
  }



  boolean searchDrum(int i, int j) {
    
    if (x == 0 || y == 0 || x == r-1 || y = c-1) { //cazuri speciale
    } else { //cazuri generale
      if (g[i][j-1].isSet == false ||
        g[i+1][j].isSet == false ||
        g[i][j+1].isSet == false ||
        g[i-1][j].isSet == false)
        return true;
      else return false;
    }

    if (i > 0 && j > 0 && i < r-1 && j < c-1) {
    } else {
      //i si j MIN
      if (i == 0 && j != 0 && j < c-1) {
        if (g[i][j-1].isSet == true &&
          g[i+1][j].isSet == true &&
          g[i][j+1].isSet == true)
          return false;
        else return true;
      }
      if (i != 0 && j == 0 && i < r-1) {
        if (g[i+1][j].isSet == true &&
          g[i][j+1].isSet == true &&
          g[i-1][j].isSet == true)
          return false;
        else return true;
      }
      if (i == 0 && j == 0) {
        if (g[i+1][j].isSet == true &&
          g[i][j+1].isSet == true)
          return false;
        else return true;
      }
      //i si j MAX
      if (i == r-2 && j != c-1 && j > 0) {
        if (g[i][j-1].isSet == true &&
          g[i][j+1].isSet == true &&
          g[i-1][j].isSet == true)
          return false;
        else return true;
      }
      if (i != r-1 && j == c-1 && i > 0) {
        if (g[i][j-1].isSet == true &&
          g[i+1][j].isSet == true &&
          g[i-1][j].isSet == true)
          return false;
        else return true;
      }
      if (i == r-1 && j == c-1) {
        if (g[i][j-1].isSet == true &&
          g[i-1][j].isSet == true)
          return false;
        else return true;
      }
      return true;
    }
  }


  //void startGenerating() {
  //  //if (!generating) {
  //  generating = true;
  //  println("generating=", generating);
  //  //}
  //}

  //void stopGenerating() {
  //  //if (generating) {
  //  generating = false; 
  //  println("generating=", generating);
  //  //}
  //}

  void delWalls(int i, int j, int dir) {
    switch (dir) {
    case 0: //SUS
      g[i][j].walls[0] = false;
      g[i][j-1].walls[2] = false;
      break;
    case 1: //DREAPTA
      g[i][j].walls[1] = false;
      g[i+1][j].walls[3] = false;
      break;
    case 2: //JOS
      g[i][j].walls[2] = false;
      g[i][j+1].walls[0] = false;
      break;
    case 3: //STANGA
      g[i][j].walls[3] = false;
      g[i-1][j].walls[1] = false;
      break;
    }
  }

  void setMaze(int i, int j) {
    g[i][j].isSet = true;
  }

  void show() {
    noStroke();
    fill(64, 224, 208);
    rect(x, y, cellW, cellH);
  }
}